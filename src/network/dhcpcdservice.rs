//! The `dhcpcdservice` module contains code that interacts with the DHCPCD client service on a
//! Linux machine.

// This module uses a Pest grammar to parse the configuration file for the DHCPCD client service.
// The configuration file represented here is only a small subset of the possibilities available
// for a full configuration file. We only implement the support for the options that are relevant
// for static network addresses.

use crate::error::FoundationError;
use crate::network::interfaceaddr::InterfaceAddr;
use crate::network::networkconfiguration::{AddressMode, NetworkConfiguration};
use crate::network::networkinterface::NetworkInterface;
use crate::network::networkservice::NetworkService;
use crate::systemctlservice::SystemCTLService;

use log::{error, info};
use pest::Parser;
use pest_derive::Parser;
use std::collections::HashMap;
use std::fs::OpenOptions;
use std::io::Write;
use std::net::IpAddr;
use std::path::PathBuf;

// See https://pest.rs for more information on Pest grammars.
#[derive(Parser)]
#[grammar = "network/dhcpcd.pest"]
pub struct DHCPCDParser;

/// The `DHCPCDConfiguration` object represents the configuration options that can be set in the
/// DHCPCD client configuration file.
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct DHCPCDConfiguration {
    rapid_commit: bool,
    domain_name: bool,
    domain_search: bool,
    classless_static_routes: bool,
    host_name: bool,
    interface_mtu: bool,
    domain_name_servers: bool,
    slaac_hwaddr: bool,
    slaac_private: bool,
    dhcp_server_identifier: bool,
    ntp_servers: bool,
    hostname: bool,
    clientid: bool,
    duid: bool,
    persistent: bool,
    vendorclassid: bool,
}

impl DHCPCDConfiguration {
    /// Create a new `DHCPCDConfiguration` object with all values initialized to false.
    pub fn new() -> DHCPCDConfiguration {
        DHCPCDConfiguration {
            rapid_commit: false,
            domain_name: false,
            domain_search: false,
            classless_static_routes: false,
            host_name: false,
            interface_mtu: false,
            domain_name_servers: false,
            slaac_hwaddr: false,
            slaac_private: false,
            dhcp_server_identifier: false,
            ntp_servers: false,
            hostname: false,
            clientid: false,
            duid: false,
            persistent: false,
            vendorclassid: false,
        }
    }
}

/// The `DHCPCDService` object is used to start, stop, and restart the DHCPCD client service on a
/// Linux machine as well as read and write the configuration file for the service.
pub struct DHCPCDService {
    // The path to the configuration file.
    filename: PathBuf,

    // The `SystemCTLService` object used to start, stop, and restart the DHCPCD service.
    service: SystemCTLService,

    // The `DHCPCDConfiguration` object that represents the configuration options that can be set in
    // the DHCPCD client configuration file.
    configuration: DHCPCDConfiguration,

    // A stack of network configurations that are being parsed from the configuration file.
    network_configuration_stack: Vec<NetworkConfiguration>,
}

impl DHCPCDService {
    /// Create a new `DHCPCDService` object.
    ///
    /// # Arguments
    ///
    /// * `filename` - The path to the configuration file.
    pub fn new(filename: PathBuf) -> DHCPCDService {
        DHCPCDService {
            filename,
            service: SystemCTLService::new("dhcpcd".to_string()),
            configuration: DHCPCDConfiguration::new(),
            network_configuration_stack: Vec::new(),
        }
    }

    #[allow(dead_code)]
    /// Get the `DHCPCDConfiguration` object that represents the configuration options that can be
    /// set in the DHCPCD client configuration file.
    pub fn get_configuration(&self) -> &DHCPCDConfiguration {
        &self.configuration
    }

    #[allow(dead_code)]
    /// Set the `DHCPCDConfiguration` object that represents the configuration options that can be
    /// set in the DHCPCD client configuration file.
    pub(crate) fn set_configuration(&mut self, configuration: DHCPCDConfiguration) {
        self.configuration = configuration;
    }
}

impl NetworkService for DHCPCDService {
    fn load_configuration(
        &mut self,
        config_map: &mut HashMap<String, NetworkConfiguration>,
    ) -> Result<(), FoundationError> {
        // These configuration files do not contain huge amounts of text, so we go ahead and load
        // the whole file into memory here.
        let file_contents = std::fs::read_to_string(&self.filename)?;

        // The Rule enums used here and below are generated by the Pest parser generator
        // code.
        let file = match DHCPCDParser::parse(Rule::file, &file_contents) {
            Ok(mut file) => file.next().unwrap(),
            Err(e) => {
                error!("Failed to parse dhcpcd.conf file: {}", e.to_string());
                return Err(FoundationError::OperationFailed(e.to_string()));
            }
        };

        // At several locations in the parser we need to whatever configurations are on the stack
        // and load them into the config_map. This function does accomplishes that load operation.
        let pop_configurations_into_map =
            |config_stack: &mut Vec<NetworkConfiguration>,
             config_map: &mut HashMap<String, NetworkConfiguration>| {
                while !config_stack.is_empty() {
                    let last_config = config_stack.pop().unwrap();
                    config_map.insert(last_config.interface.name.clone(), last_config);
                }
            };

        // The rules for using Rules from the parser are a bit complicated.  See the source grammar
        // file dhcpdcd.pest and [https://pest.rs] for more information.
        for line in file.into_inner() {
            for decl in line.clone().into_inner() {
                for thing in decl.into_inner() {
                    match thing.as_rule() {
                        Rule::extended_dns_server_option => {
                            self.configuration.domain_name_servers = true;
                            self.configuration.domain_name = true;
                            self.configuration.domain_search = true;
                        }
                        Rule::domain_name_dns_server_option => {
                            self.configuration.domain_name_servers = true;
                            self.configuration.domain_name = true;
                        }
                        Rule::dns_server_option => {
                            self.configuration.domain_name_servers = true;
                        }
                        Rule::classless_static_route_option => {
                            self.configuration.classless_static_routes = true;
                        }
                        Rule::interface_mtu_option => {
                            self.configuration.interface_mtu = true;
                        }
                        Rule::host_name_option => {
                            self.configuration.host_name = true;
                        }
                        Rule::ntp_servers_option => {
                            self.configuration.ntp_servers = true;
                        }
                        Rule::rapid_commit_option => {
                            self.configuration.rapid_commit = true;
                        }
                        Rule::dhcp_server_identifier_require => {
                            self.configuration.dhcp_server_identifier = true;
                        }
                        Rule::slaac_hwaddr => {
                            self.configuration.slaac_hwaddr = true;
                        }
                        Rule::slaac_private => {
                            self.configuration.slaac_private = true;
                        }
                        Rule::hostname => {
                            self.configuration.hostname = true;
                        }
                        Rule::clientid => {
                            self.configuration.clientid = true;
                        }
                        Rule::duid => {
                            self.configuration.duid = true;
                        }
                        Rule::persistent => {
                            self.configuration.persistent = true;
                        }
                        Rule::vendorclassid => {
                            self.configuration.vendorclassid = true;
                        }
                        Rule::interface => {
                            // Handle any previously parsed network configuration.
                            pop_configurations_into_map(
                                &mut self.network_configuration_stack,
                                config_map,
                            );

                            let text = thing.into_inner();
                            let interface_name = text.as_str();
                            let interface = NetworkInterface::new_with_name(interface_name);
                            let config = NetworkConfiguration::new(
                                AddressMode::DHCP,
                                interface,
                                true,
                                None,
                                None,
                            );
                            self.network_configuration_stack.push(config);
                        }
                        Rule::static_ip_address => {
                            let mut text = thing.into_inner();
                            let address = text.next().unwrap().as_str();
                            if let Ok(interface_addr) = InterfaceAddr::try_from(address) {
                                if let Some(config) = self.network_configuration_stack.last_mut() {
                                    config.address_mode = AddressMode::Static;
                                    config.interface.addresses.push(interface_addr);
                                } else {
                                    error!("Encountered a static IPv4 address in config file without a corresponding interface declaration.");
                                }
                            } else {
                                error!("Encountered a static IPv4 address in config file that does not parse to an InterfaceAddr: {}", address);
                            }
                        }
                        Rule::static_routers => {
                            let address_text = thing.into_inner().as_str();
                            let addresses = address_text.split(" ").collect::<Vec<&str>>();
                            if let Some(config) = self.network_configuration_stack.last_mut() {
                                for address in addresses {
                                    if let Ok(ip) = address.parse() {
                                        config.interface.gateway_addresses.push(ip);
                                    } else {
                                        error!("Encountered a static router in config file that does not parse to an IpAddr: {}", address);
                                    }
                                }
                            } else {
                                error!("Encountered a static router in config file without a corresponding interface declaration.");
                            }
                        }
                        Rule::static_domain_name_servers => {
                            let address_text = thing.into_inner().as_str();
                            let addresses = address_text.split(" ").collect::<Vec<&str>>();
                            if let Some(config) = self.network_configuration_stack.last_mut() {
                                for address in addresses {
                                    if let Ok(ip) = address.parse() {
                                        config.interface.nameserver_addresses.push(ip);
                                    } else {
                                        error!("Encountered a static router in config file that does not parse to an IpAddr: {}", address);
                                    }
                                }
                            } else {
                                error!("Encountered a static router in config file without a corresponding interface declaration.");
                            }
                        }
                        _ => {
                            info!("{:?}", thing.as_rule());
                        }
                    }
                }
            }
        }

        // Now handle any dangling configurations and put them in the config map.
        pop_configurations_into_map(&mut self.network_configuration_stack, config_map);

        Ok(())
    }

    fn write_configuration(
        &self,
        configurations: &HashMap<String, NetworkConfiguration>,
    ) -> Result<(), FoundationError> {
        match OpenOptions::new()
            .write(true)
            .truncate(true)
            .create(true)
            .open(&self.filename)
        {
            Ok(mut file) => {
                if self.configuration.hostname {
                    writeln!(file, "hostname")?;
                }
                if self.configuration.clientid {
                    writeln!(file, "clientid")?;
                }
                if self.configuration.duid {
                    writeln!(file, "duid")?;
                }
                if self.configuration.persistent {
                    writeln!(file, "persistent")?;
                }
                if self.configuration.rapid_commit {
                    writeln!(file, "option rapid_commit")?;
                }
                if self.configuration.host_name {
                    writeln!(file, "option host_name")?;
                }
                if self.configuration.domain_name_servers
                    || self.configuration.domain_name
                    || self.configuration.domain_search
                {
                    write!(file, "option ")?;
                }
                let mut needs_comma = false;
                if self.configuration.domain_name_servers {
                    write!(file, "domain_name_servers")?;
                    needs_comma = true;
                }
                if self.configuration.domain_name {
                    if needs_comma {
                        write!(file, ", ")?;
                    }
                    write!(file, "domain_name")?;
                    needs_comma = true;
                }
                if self.configuration.domain_search {
                    if needs_comma {
                        write!(file, ", ")?;
                    }
                    write!(file, "domain_search")?;
                }
                if self.configuration.domain_name_servers
                    || self.configuration.domain_name
                    || self.configuration.domain_search
                {
                    writeln!(file, "")?;
                }
                if self.configuration.classless_static_routes {
                    writeln!(file, "option classless_static_routes")?;
                }
                if self.configuration.interface_mtu {
                    writeln!(file, "option interface_mtu")?;
                }
                if self.configuration.dhcp_server_identifier {
                    writeln!(file, "require dhcp_server_identifier")?;
                }
                if self.configuration.slaac_private {
                    writeln!(file, "slaac private")?;
                }
                if self.configuration.slaac_hwaddr {
                    writeln!(file, "slaac hwaddr")?;
                }

                let write_config_to_file = |f: &mut std::fs::File,
                                            config: &NetworkConfiguration|
                 -> Result<(), FoundationError> {
                    if config.wifi_configuration.is_some() {
                        return Ok(());
                    }

                    if config.enabled && config.address_mode == AddressMode::Static {
                        writeln!(f, "interface {}", config.interface.name)?;

                        for addr in &config.interface.addresses {
                            let ip_address_str = if addr.ip.is_ipv4() {
                                "ip_address".to_string()
                            } else {
                                "ip6_address".to_string()
                            };

                            if let Some(cidr_notation) = addr.get_in_cidr_notation() {
                                writeln!(f, "static {} {}", ip_address_str, cidr_notation)?;
                            }
                        }

                        let write_address_list_to_file =
                            |f: &mut std::fs::File,
                             phrase: &str,
                             address_list: &Vec<IpAddr>|
                             -> Result<(), FoundationError> {
                                if address_list.len() > 0 {
                                    write!(f, "{}", phrase)?;
                                }
                                let addr_data = address_list
                                    .iter()
                                    .map(|addr| addr.to_string())
                                    .collect::<Vec<_>>()
                                    .join(" ");
                                if !addr_data.is_empty() {
                                    writeln!(f, "{}", addr_data)?;
                                }
                                Ok(())
                            };

                        write_address_list_to_file(
                            f,
                            "static routers ",
                            &config.interface.gateway_addresses,
                        )?;
                        write_address_list_to_file(
                            f,
                            "static domain_name_servers ",
                            &config.interface.nameserver_addresses,
                        )?;
                        writeln!(f, "")?;
                    } else if config.enabled && config.address_mode == AddressMode::DHCP {
                        writeln!(f, "interface {}", config.interface.name)?;
                    }
                    Ok(())
                };

                for (_, config) in configurations {
                    write_config_to_file(&mut file, config)?;
                }

                Ok(())
            }
            Err(e) => Err(FoundationError::IO(e)),
        }
    }

    fn get_configuration_file(&self) -> PathBuf {
        self.filename.clone()
    }

    fn start(&self) -> Result<(), FoundationError> {
        self.service.start()
    }

    fn stop(&self) -> Result<(), FoundationError> {
        self.service.stop()
    }

    fn restart(&self) -> Result<(), FoundationError> {
        self.service.restart()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::net::Ipv4Addr;

    // Note that this service can lose configuration fidelity in the sense that the dhcpcd configuration
    // file does not contain all settings supported by this library's notion of a network configuration.
    // When testing, be sure to understand what the service supports so that you only add enough to
    // configuration to test the service's ability to read and write the configuration file.  If you
    // add more, then the configurations will not match after you write the config, read it back and
    // then compare it to the read results (because the read config will contain less information).
    #[test]
    fn test_load_dhcpcd_service() {
        let mut dhcpcd_config = DHCPCDConfiguration::new();
        dhcpcd_config.hostname = true;
        dhcpcd_config.clientid = true;
        dhcpcd_config.duid = true;
        dhcpcd_config.persistent = true;
        dhcpcd_config.rapid_commit = true;
        dhcpcd_config.domain_name_servers = true;
        dhcpcd_config.domain_name = true;
        dhcpcd_config.domain_search = true;
        dhcpcd_config.classless_static_routes = true;
        dhcpcd_config.interface_mtu = true;
        dhcpcd_config.host_name = true;
        dhcpcd_config.ntp_servers = true;
        dhcpcd_config.dhcp_server_identifier = true;
        dhcpcd_config.slaac_private = true;

        let mut interface = NetworkInterface::new_with_name("eth0");
        interface.addresses.push(InterfaceAddr::new(
            IpAddr::V4(Ipv4Addr::new(10, 0, 0, 13)),
            None,
            Some(IpAddr::V4(Ipv4Addr::new(255, 255, 255, 0))),
        ));
        interface
            .gateway_addresses
            .push(IpAddr::V4(Ipv4Addr::new(10, 0, 0, 1)));
        interface
            .gateway_addresses
            .push(IpAddr::V4(Ipv4Addr::new(11, 12, 13, 14)));
        interface
            .nameserver_addresses
            .push(IpAddr::V4(Ipv4Addr::new(8, 8, 8, 8)));
        interface
            .nameserver_addresses
            .push(IpAddr::V4(Ipv4Addr::new(8, 8, 4, 4)));
        let config = NetworkConfiguration::new(AddressMode::Static, interface, true, None, None);
        let mut config_map: HashMap<String, NetworkConfiguration> = HashMap::new();
        config_map.insert("eth0".to_string(), config);

        let interface2 = NetworkInterface::new_with_name("eth1");
        let config = NetworkConfiguration::new(AddressMode::DHCP, interface2, true, None, None);
        config_map.insert("eth1".to_string(), config);

        let mut dhcpcd_service = DHCPCDService::new(PathBuf::from("/tmp/dhcpcd2.conf"));
        dhcpcd_service.set_configuration(dhcpcd_config.clone());

        let result = dhcpcd_service.write_configuration(&config_map);
        assert!(result.is_ok());

        let mut other_config_map: HashMap<String, NetworkConfiguration> = HashMap::new();
        let result = dhcpcd_service.load_configuration(&mut other_config_map);
        assert!(result.is_ok());
        assert_eq!(config_map, other_config_map);

        let other_dhcpc_config = dhcpcd_service.get_configuration();
        assert_eq!(dhcpcd_config, *other_dhcpc_config);
    }
}
